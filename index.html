<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>W8Team</title>
    <style>
      html, body {
        margin: 0;
        height: 100%;
        background: #000; /* পিওর ব্ল্যাক ব্যাকগ্রাউন্ড */
        overflow: hidden;
      }
      canvas {
        width: 100vw;
        height: 100vh;
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="gl"></canvas>
    <audio id="bgAudio" src="Louad3.mp3" loop></audio>

    <script>
      // Auto-play audio (যতটা ব্রাউজার অনুমতি দেয়)
      const audio = document.getElementById("bgAudio");
      audio.volume = 0.9;
      audio.loop = true;

      // Force play on page load
      window.addEventListener("load", () => {
        audio.play().catch(e => console.log("Autoplay blocked:", e));
      });

      // Also try to play immediately
      audio.play().catch(e => {
        // Fallback: play on any user interaction
        const playAudio = () => {
          audio.play();
          document.removeEventListener("click", playAudio);
          document.removeEventListener("keydown", playAudio);
        };
        document.addEventListener("click", playAudio);
        document.addEventListener("keydown", playAudio);
      });

      const canvas = document.getElementById("gl");

      // Click anywhere to restart the sound
      canvas.addEventListener("click", () => {
        audio.currentTime = 0;
        audio.play();
      });

      const gl = canvas.getContext("webgl");
      if (!gl) { alert("WebGL not supported"); }

      function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = innerWidth * dpr;
        canvas.height = innerHeight * dpr;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      resize();
      addEventListener("resize", resize);

      function compile(src, type) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(s));
        }
        return s;
      }

      const vs = compile(
        `attribute vec2 p;
         void main(){
           gl_Position = vec4(p, 0.0, 1.0);
         }`,
        gl.VERTEX_SHADER
      );

      // নতুন হ্যাকার / ম্যাট্রিক্স টাইপ fragment shader
      const fs = compile(`
precision highp float;

uniform vec2  R;
uniform float T;
uniform float density;
uniform float scatter;
uniform float speed;
uniform float lightI;

float hash(vec2 p){
  p = fract(p * vec2(123.34, 456.21));
  p += dot(p, p + 45.32);
  return fract(p.x * p.y);
}

void main(){
  // 0–1 UV
  vec2 uv = gl_FragCoord.xy / R;
  // Center UV for vignette
  vec2 cuv = (uv - 0.5) * 2.0;
  float dist = length(cuv);

  // কলাম / রো সংখ্যা (density দিয়ে একটু কন্ট্রোল)
  float cols = 60.0 + density * 6.0;  // 60–90
  float rows = 40.0 + density * 4.0;  // 40–60

  // downwards speed (speed দিয়ে কন্ট্রোল)
  float t = T * (0.7 + speed * 0.2);

  // এই পিক্সেল কোন কলাম / রো তে
  float column = floor(uv.x * cols);
  float row    = floor((uv.y + t) * rows);

  // র‍্যান্ডম চিহ্ন অন/অফ
  float base = hash(vec2(column, row));

  // রেইন ট্রেইল ইফেক্ট
  float yPos  = fract(uv.y * rows + t);
  float trail = exp(-yPos * 10.0);          // নিচের দিকে ট্রেইল
  float head  = smoothstep(0.0, 0.15, yPos) * 0.9; // হেড অংশ

  // কিছু পিক্সেলই শুধু অন
  float charOn = step(0.8, base);

  float intensity = (trail + head) * charOn;

  // lightI দিয়ে গ্লো কিছুটা বাড়ানো/কমানো
  float glow = 0.4 + lightI * 0.08; // lightI=5 -> ~0.8
  vec3 green = vec3(0.1, 1.0, 0.3);
  vec3 col   = vec3(0.0);

  col += green * intensity * glow;

  // subtle scan-line effect
  float line = sin(gl_FragCoord.y * 3.14159) * 0.04;
  col *= (1.0 - line);

  // vignette (চারদিকে ডার্ক)
  float vig = smoothstep(1.4, 0.3, dist);
  col *= vig;

  // ডার্ক ব্যাকগ্রাউন্ড বেস
  col += vec3(0.0, 0.05, 0.0);

  gl_FragColor = vec4(col, 1.0);
}
`, gl.FRAGMENT_SHADER);

      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      gl.useProgram(prog);

      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([
          -1,-1,  1,-1, -1, 1,
          -1, 1,  1,-1,  1, 1
        ]),
        gl.STATIC_DRAW
      );

      const loc = {
        p:       gl.getAttribLocation(prog, "p"),
        R:       gl.getUniformLocation(prog, "R"),
        T:       gl.getUniformLocation(prog, "T"),
        density: gl.getUniformLocation(prog, "density"),
        scatter: gl.getUniformLocation(prog, "scatter"),
        speed:   gl.getUniformLocation(prog, "speed"),
        lightI:  gl.getUniformLocation(prog, "lightI")
      };

      gl.enableVertexAttribArray(loc.p);
      gl.vertexAttribPointer(loc.p, 2, gl.FLOAT, false, 0, 0);

      // আগের মতই মান, কিন্তু নতুন shader এগুলা safe ভাবে use করছে
      gl.uniform1f(loc.density, 5.0);
      gl.uniform1f(loc.scatter, 2.0);
      gl.uniform1f(loc.speed,   2.0);
      gl.uniform1f(loc.lightI,  5.0);

      let t0 = performance.now();
      function draw() {
        requestAnimationFrame(draw);
        gl.uniform2f(loc.R, canvas.width, canvas.height);
        gl.uniform1f(loc.T, (performance.now() - t0) / 1000.0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
      draw();
    </script>
  </body>
</html>
