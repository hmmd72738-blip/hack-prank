<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>W8Team</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #000;
        overflow: hidden;
      }

      body {
        position: relative;
      }

      /* WebGL canvas ‚Äì ‡¶´‡ßÅ‡¶≤ ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶® */
      canvas {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        display: block;
        z-index: 1;
      }

      /* ‡¶Æ‡¶æ‡¶ù‡ßá‡¶∞ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶∂‡ßÅ‡¶≠‡ßá‡¶ö‡ßç‡¶õ‡¶æ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‚Äì ‡¶π‡ßÅ‡¶°‡¶ø ‡¶ó‡ßç‡¶≤‡ßã ‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤ */
      .center-text {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        font-family: system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, sans-serif;
        color: #22c55e;
        font-size: 20px;
        line-height: 1.7;
        pointer-events: none;
        padding: 10px 18px;
        border-radius: 14px;
        background: rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(34, 197, 94, 0.4);
        text-shadow: 0 0 8px rgba(34, 197, 94, 0.9),
                     0 0 22px rgba(34, 197, 94, 0.7);
        animation: textGlow 1.8s ease-in-out infinite;
        z-index: 3;
      }

      .center-text span {
        display: block;
      }

      @keyframes textGlow {
        0% {
          opacity: 0.8;
        }
        50% {
          opacity: 1;
          text-shadow: 0 0 14px rgba(34, 197, 94, 1),
                       0 0 30px rgba(34, 197, 94, 0.9);
        }
        100% {
          opacity: 0.85;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="gl"></canvas>
    <audio id="bgAudio" src="Louad3.mp3" loop></audio>

    <!-- ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ ‡¶∂‡ßÅ‡¶≠‡ßá‡¶ö‡ßç‡¶õ‡¶æ ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú -->
    <div class="center-text">
      <span>‡¶á‡ßü‡¶æ‡¶∏‡¶ø‡¶® ‡¶Ü‡¶¶‡¶®‡¶æ‡¶®‡ßá‡¶∞ ‡¶™‡¶ï‡ßç‡¶∑ ‡¶•‡ßá‡¶ï‡ßá ‡¶∂‡ßÅ‡¶≠‡ßá‡¶ö‡ßç‡¶õ‡¶æüéâ</span>
      <span>‡¶≠‡¶æ‡¶≤‡ßã ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡¶®‚ò∫Ô∏è</span>
    </div>

    <script>
      // ----- ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ (‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶Æ‡¶§) -----
      const audio = document.getElementById("bgAudio");
      audio.volume = 0.9;
      audio.loop = true;

      window.addEventListener("load", () => {
        audio.play().catch(e => console.log("Autoplay blocked:", e));
      });

      audio.play().catch(e => {
        const playAudio = () => {
          audio.play();
          document.removeEventListener("click", playAudio);
          document.removeEventListener("keydown", playAudio);
        };
        document.addEventListener("click", playAudio);
        document.addEventListener("keydown", playAudio);
      });

      const canvas = document.getElementById("gl");

      // ‡¶ï‡ßç‡¶Ø‡¶æ‡¶®‡¶≠‡¶æ‡¶∏‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï = ‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶ü
      canvas.addEventListener("click", () => {
        audio.currentTime = 0;
        audio.play();
      });

      const gl = canvas.getContext("webgl");
      if (!gl) { alert("WebGL not supported"); }

      function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width  = innerWidth  * dpr;
        canvas.height = innerHeight * dpr;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      resize();
      addEventListener("resize", resize);

      function compile(src, type) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(s));
        }
        return s;
      }

      const vs = compile(
`attribute vec2 p;
void main(){
  gl_Position = vec4(p, 0.0, 1.0);
}`, gl.VERTEX_SHADER);

      // ===== ‡¶®‡¶§‡ßÅ‡¶® 3D ‡¶ó‡ßá‡¶Æ-‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤ fragment shader =====
      const fs = compile(`
precision highp float;

uniform vec2  R;
uniform float T;
uniform float density;
uniform float scatter;
uniform float speed;
uniform float lightI;

// --- SDF helpers ---
float sdBox(vec3 p, vec3 b){
  vec3 q = abs(p) - b;
  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdPlane(vec3 p){
  return p.y;
}

float opUnion(float d1, float d2){
  return min(d1, d2);
}

// simple hash
float hash(vec3 p){
  p = fract(p * 0.3183099 + vec3(0.1,0.2,0.3));
  p *= 17.0;
  return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
}

// scene distance
float mapScene(vec3 p, out int matId){
  // island base (‡¶â‡¶™‡¶∞‡ßá ‡¶â‡¶†‡¶æ‡¶®‡ßã ‡¶™‡ßç‡¶≤‡ßç‡¶Ø‡¶æ‡¶ü‡¶´‡¶∞‡ßç‡¶Æ)
  float island = sdBox(p - vec3(0.0, -0.6, 0.0), vec3(2.2, 0.6, 2.2));

  // house body
  float house = sdBox(p - vec3(0.0, 0.4, 0.0), vec3(0.6, 0.5, 0.6));

  // roof (slanted box)
  vec3 pr = p - vec3(0.0, 0.95, 0.0);
  pr.yz *= mat2(0.8, -0.6, 0.6, 0.8);
  float roof = sdBox(pr, vec3(0.8, 0.35, 0.8));

  // ‡¶õ‡ßã‡¶ü ‡¶ö‡¶ø‡¶Æ‡¶®‡¶ø
  float chimney = sdBox(p - vec3(0.25, 1.2, 0.0), vec3(0.15, 0.3, 0.15));

  // ground plane (‡¶¶‡ßç‡¶¨‡ßÄ‡¶™‡ßá‡¶∞ ‡¶®‡¶ø‡¶ö‡ßá ‡¶∂‡ßç‡¶Ø‡¶æ‡¶°‡ßã‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø)
  float plane = sdPlane(p + vec3(0.0, 1.0, 0.0));

  float d = island;
  matId = 1;

  if (house < d) { d = house; matId = 2; }
  if (roof < d)  { d = roof;  matId = 3; }
  if (chimney < d){ d = chimney; matId = 4; }
  if (plane < d) { d = plane; matId = 5; }

  return d;
}

vec3 getNormal(vec3 p){
  const vec2 e = vec2(0.001, 0.0);
  int m;
  float d = mapScene(p, m);
  vec3 n;
  n.x = mapScene(p + e.xyy, m) - d;
  n.y = mapScene(p + e.yxy, m) - d;
  n.z = mapScene(p + e.yyx, m) - d;
  return normalize(n);
}

// soft shadow
float softShadow(vec3 ro, vec3 rd){
  float res = 1.0;
  float t = 0.05;
  for (int i = 0; i < 40; i++){
    vec3 p = ro + rd * t;
    int mid;
    float h = mapScene(p, mid);
    res = min(res, 8.0 * h / t);
    t += clamp(h, 0.02, 0.25);
    if (h < 0.001 || t > 18.0) break;
  }
  return clamp(res, 0.0, 1.0);
}

// window emission mask
float windowMask(vec3 p){
  // house local space
  vec3 h = p - vec3(0.0, 0.4, 0.0);
  float w = 0.0;

  // front windows
  vec3 w1 = h;
  w1.z -= 0.61;
  w1.y -= 0.1;
  w1.x = abs(w1.x);
  w = max(w, 1.0 - smoothstep(0.05, 0.09, abs(w1.x)));
  w *= step(abs(w1.y), 0.18);

  // side window
  vec3 w2 = h;
  w2.x -= 0.61;
  w2.y -= 0.05;
  w2.z = abs(w2.z);
  float side = step(abs(w2.z), 0.14) * step(abs(w2.y), 0.16);
  w = max(w, side);

  return w;
}

void main(){
  vec2 uv = (gl_FragCoord.xy / R) * 2.0 - 1.0;
  uv.x *= R.x / R.y;

  float t = T;

  // ‡¶ï‡ßç‡¶Ø‡¶æ‡¶Æ‡ßá‡¶∞‡¶æ ‡¶è‡¶ï‡¶ü‡ßÅ ‡¶ò‡ßÅ‡¶∞‡ßá ‡¶¨‡ßá‡¶°‡¶º‡¶æ‡¶¨‡ßá
  float camRad = 4.0;
  float camH   = 1.6;
  float angle  = t * 0.35;
  vec3 ro = vec3(
    camRad * sin(angle),
    camH,
    camRad * cos(angle)
  );
  vec3 ta = vec3(0.0, 0.4, 0.0);

  vec3 fw = normalize(ta - ro);
  vec3 rt = normalize(cross(vec3(0.0,1.0,0.0), fw));
  vec3 up = cross(fw, rt);

  vec3 rd = normalize(rt * uv.x + up * uv.y + fw * 1.5);

  // sky gradient
  vec3 skyTop = vec3(0.06, 0.08, 0.18);
  vec3 skyBot = vec3(0.01, 0.01, 0.04);
  float skyMix = 0.5 + 0.5 * rd.y;
  vec3 col = mix(skyBot, skyTop, skyMix);

  // directional light
  vec3 L = normalize(vec3(0.4, 0.8, -0.3));

  // raymarch
  float tMin = 0.0;
  float tMax = 30.0;
  float distTravel = tMin;
  int matId = 0;
  float d;

  for (int i = 0; i < 96; i++){
    vec3 p = ro + rd * distTravel;
    d = mapScene(p, matId);
    if (d < 0.001 || distTravel > tMax) break;
    distTravel += d * 0.75;
  }

  if (d < 0.01){
    vec3 p = ro + rd * distTravel;
    vec3 n = getNormal(p);

    float diff = max(dot(n, L), 0.0);
    float sh   = softShadow(p + n * 0.02, L);
    diff *= sh;

    float ao = 0.5 + 0.5 * clamp(1.0 - distTravel * 0.06, 0.0, 1.0);

    // base colors
    vec3 baseColor;
    if (matId == 1){
      baseColor = vec3(0.20, 0.26, 0.18); // island
    } else if (matId == 2){
      baseColor = vec3(0.40, 0.32, 0.30); // house body
    } else if (matId == 3){
      baseColor = vec3(0.55, 0.26, 0.18); // roof
    } else if (matId == 4){
      baseColor = vec3(0.48, 0.30, 0.26); // chimney
    } else {
      baseColor = vec3(0.02, 0.02, 0.05); // ground plane
    }

    // fake rim light
    float rim = pow(1.0 - max(dot(n, -rd), 0.0), 2.0);

    // window emission
    float wMask = windowMask(p);
    float flick = 0.7 + 0.3 * sin(T * 6.0 + hash(p) * 10.0);
    vec3 windowColor = vec3(1.8, 1.55, 0.9) * wMask * flick;

    vec3 lightCol = vec3(1.0, 0.96, 0.9);

    vec3 lit = baseColor * (0.18 + diff * 1.6) * lightCol * ao;
    lit += rim * 0.15;
    lit += windowColor;

    // lightI / density ‡¶∏‡¶æ‡¶Æ‡¶æ‡¶®‡ßç‡¶Ø ‡¶¨‡ßÅ‡¶∏‡ßç‡¶ü ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá
    float boost = 0.8 + 0.05 * lightI + 0.03 * density;
    lit *= boost;

    col = lit;
  }

  // subtle vignette
  float r = length(uv);
  float vign = smoothstep(1.2, 0.4, r);
  col *= vign;

  // ‡¶∏‡¶æ‡¶Æ‡¶æ‡¶®‡ßç‡¶Ø ‡¶ó‡¶æ‡¶Æ‡¶æ
  col = pow(col, vec3(0.9));

  gl_FragColor = vec4(col, 1.0);
}
`, gl.FRAGMENT_SHADER);

      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      gl.useProgram(prog);

      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]),
        gl.STATIC_DRAW
      );

      const loc = {
        p: gl.getAttribLocation(prog, "p"),
        R: gl.getUniformLocation(prog, "R"),
        T: gl.getUniformLocation(prog, "T"),
        density: gl.getUniformLocation(prog, "density"),
        scatter: gl.getUniformLocation(prog, "scatter"),
        speed: gl.getUniformLocation(prog, "speed"),
        lightI: gl.getUniformLocation(prog, "lightI")
      };

      gl.enableVertexAttribArray(loc.p);
      gl.vertexAttribPointer(loc.p, 2, gl.FLOAT, false, 0, 0);

      // ‡¶â‡¶ö‡ßç‡¶ö ‡¶Æ‡¶æ‡¶® ‚Äì ‡¶π‡ßá‡¶≠‡¶ø ‡¶´‡¶ø‡¶≤ ‡¶•‡¶æ‡¶ï‡¶¨‡ßá
      gl.uniform1f(loc.density, 5.0);
      gl.uniform1f(loc.scatter, 2.0);
      gl.uniform1f(loc.speed,   2.0);
      gl.uniform1f(loc.lightI,  5.0);

      let t0 = performance.now();
      function draw(){
        requestAnimationFrame(draw);
        gl.uniform2f(loc.R, canvas.width, canvas.height);
        gl.uniform1f(loc.T, (performance.now() - t0) / 1000);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
      draw();
    </script>
  </body>
</html>
