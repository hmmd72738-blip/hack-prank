<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>W8Team</title>
    <style>
      html, body {
        margin: 0;
        height: 100%;
        background: radial-gradient(circle at top, #0b1120, #020617 60%, #000000);
        overflow: hidden;
      }
      canvas {
        width: 100vw;
        height: 100vh;
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="gl"></canvas>
    <audio id="bgAudio" src="Louad3.mp3" loop></audio>

    <script>
      // Auto-play audio (যতটা ব্রাউজার অনুমতি দেয়)
      const audio = document.getElementById("bgAudio");
      audio.volume = 0.9;
      audio.loop = true;

      // Force play on page load
      window.addEventListener("load", () => {
        audio.play().catch(e => console.log("Autoplay blocked:", e));
      });

      // Also try to play immediately
      audio.play().catch(e => {
        // Fallback: play on any user interaction
        const playAudio = () => {
          audio.play();
          document.removeEventListener("click", playAudio);
          document.removeEventListener("keydown", playAudio);
        };
        document.addEventListener("click", playAudio);
        document.addEventListener("keydown", playAudio);
      });

      const canvas = document.getElementById("gl");

      // Click anywhere to restart the sound
      canvas.addEventListener("click", () => {
        audio.currentTime = 0;
        audio.play();
      });

      const gl = canvas.getContext("webgl");
      if (!gl) { alert("WebGL not supported"); }

      function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = innerWidth * dpr;
        canvas.height = innerHeight * dpr;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      resize();
      addEventListener("resize", resize);

      function compile(src, type) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(s));
        }
        return s;
      }

      const vs = compile(
        `attribute vec2 p;
         void main(){
           gl_Position = vec4(p, 0.0, 1.0);
         }`,
        gl.VERTEX_SHADER
      );

      const fs = compile(`
precision highp float;

uniform vec2 R;
uniform float T;
uniform float density;
uniform float scatter;
uniform float speed;
uniform float lightI;

float noise(vec3 p){
  float n = 0.0, a = 0.6;
  for(int i = 0; i < 4; i++){
    n += (sin(p.x) + sin(p.y) + sin(p.z)) * 0.33 * a;
    p *= 1.8;
    a *= 0.55;
  }
  return n * 0.5 + 0.5;
}

float field(vec3 p){
  float base = noise(p * 1.2 + vec3(0.0, T * speed * 0.2, 0.0));
  float c    = noise(p * 3.0 + vec3(7.0, 2.0, 9.0) + T * speed * 0.5);
  float h    = smoothstep(0.6, -0.6, p.y);
  return clamp((base * 0.9 + c * 0.4) * h * density, 0.0, 1.0);
}

void main(){
  vec2 uv = (gl_FragCoord.xy / R) * 2.0 - 1.0;
  uv.x *= R.x / R.y;

  vec3 ro = vec3(3.0, 1.2, 3.0);
  vec3 ta = vec3(0.0, 0.4, 0.0);
  vec3 f  = normalize(ta - ro);
  vec3 r  = normalize(cross(vec3(0.0, 1.0, 0.0), f));
  vec3 u  = cross(f, r);
  vec3 rd = normalize(r * uv.x + u * uv.y + f * 1.6);

  vec3 L = normalize(vec3(-0.5, 0.6, -0.8));
  vec3 tint = vec3(0.95, 0.35, 0.65); // একটু বেশি পিংকিশ গ্লো
  // নতুন sky: উপরে ডার্ক পার্পল, নিচে ব্ল্যাক টাইপ গ্রেডিয়েন্ট
  vec2 suv = gl_FragCoord.xy / R;
  vec3 skyTop    = vec3(0.06, 0.02, 0.20);
  vec3 skyBottom = vec3(0.0, 0.0, 0.0);
  vec3 sky = mix(skyBottom, skyTop, suv.y);

  float t = 0.0, dt = 0.25, md = 20.0, A = 0.0;
  vec3 C = vec3(0.0);

  for(int i = 0; i < 80; i++){
    vec3 p = ro + rd * t;
    float d   = field(p);
    float ext = d * 1.4;

    float lt = 1.0;
    vec3 lp = p;
    for(int j = 0; j < 6; j++){
      lp += L * 0.8;
      lt *= exp(-field(lp) * 0.5);
    }

    float ph = scatter;
    vec3 s   = tint * d * lt * lightI * ph;

    float a = 1.0 - exp(-ext * dt);
    a *= (1.0 - A);

    C += s * a;
    A += a;

    t += dt;
    if(t > md || A > 0.99) break;
  }

  vec3 col = mix(sky, C + sky * 0.25, A);
  col = pow(col, vec3(0.75));
  gl_FragColor = vec4(col, 1.0);
}
`, gl.FRAGMENT_SHADER);

      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      gl.useProgram(prog);

      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([
          -1,-1,  1,-1, -1, 1,
          -1, 1,  1,-1,  1, 1
        ]),
        gl.STATIC_DRAW
      );

      const loc = {
        p:       gl.getAttribLocation(prog, "p"),
        R:       gl.getUniformLocation(prog, "R"),
        T:       gl.getUniformLocation(prog, "T"),
        density: gl.getUniformLocation(prog, "density"),
        scatter: gl.getUniformLocation(prog, "scatter"),
        speed:   gl.getUniformLocation(prog, "speed"),
        lightI:  gl.getUniformLocation(prog, "lightI")
      };

      gl.enableVertexAttribArray(loc.p);
      gl.vertexAttribPointer(loc.p, 2, gl.FLOAT, false, 0, 0);

      // MAXIMUM VALUES (আগের মতোই)
      gl.uniform1f(loc.density, 5.0);
      gl.uniform1f(loc.scatter, 2.0);
      gl.uniform1f(loc.speed,   2.0);
      gl.uniform1f(loc.lightI,  5.0);

      let t0 = performance.now();
      function draw() {
        requestAnimationFrame(draw);
        gl.uniform2f(loc.R, canvas.width, canvas.height);
        gl.uniform1f(loc.T, (performance.now() - t0) / 1000.0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
      draw();
    </script>
  </body>
</html>
