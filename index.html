<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>W8Team</title>
    <style>
      html, body {
        margin: 0;
        height: 100%;
        background: #000; /* ‡¶™‡ßÅ‡¶∞‡ßã ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶ó‡ßç‡¶∞‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶ï‡¶æ‡¶≤‡ßã */
        overflow: hidden;
      }
      canvas {
        width: 100vw;
        height: 100vh;
        display: block;
      }
      /* ‡¶Æ‡¶æ‡¶ù‡ßá‡¶∞ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü */
      .center-text {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        font-family: system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, sans-serif;
        color: #22c55e;
        text-shadow: 0 0 8px rgba(34, 197, 94, 0.9),
                     0 0 18px rgba(34, 197, 94, 0.7);
        font-size: 18px;
        line-height: 1.6;
        pointer-events: none; /* ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡ßç‡¶Ø‡¶æ‡¶®‡¶≠‡¶æ‡¶∏‡ßá‡¶á ‡¶Ø‡¶æ‡¶¨‡ßá */
        animation: textPulse 1.8s ease-in-out infinite;
        padding: 8px 14px;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(34, 197, 94, 0.4);
      }
      .center-text span {
        display: block;
      }
      @keyframes textPulse {
        0% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0.8;
        }
        50% {
          transform: translate(-50%, -50%) scale(1.06);
          opacity: 1;
          text-shadow: 0 0 14px rgba(34, 197, 94, 1),
                       0 0 28px rgba(34, 197, 94, 0.9);
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0.85;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="gl"></canvas>
    <audio id="bgAudio" src="Louad3.mp3" loop></audio>

    <!-- ‡¶Æ‡¶æ‡¶ù‡ßá‡¶∞ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü (‡¶≤‡¶æ‡¶á‡¶≠ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶®‡¶ø‡¶Æ‡ßá‡¶∂‡¶®) -->
    <div class="center-text">
      <span>‡¶á‡ßü‡¶æ‡¶∏‡¶ø‡¶® ‡¶Ü‡¶¶‡¶®‡¶æ‡¶®‡ßá‡¶∞ ‡¶™‡¶ï‡ßç‡¶∑ ‡¶•‡ßá‡¶ï‡ßá ‡¶∂‡ßÅ‡¶≠‡ßá‡¶ö‡ßç‡¶õ‡¶æüéâ</span>
      <span>‡¶≠‡¶æ‡¶≤‡ßã ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡¶®‚ò∫Ô∏è</span>
    </div>

    <script>
      // ----- ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ (‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶Æ‡¶§‡¶á) -----
      const audio = document.getElementById("bgAudio");
      audio.volume = 0.9;
      audio.loop = true;

      window.addEventListener("load", () => {
        audio.play().catch(e => console.log("Autoplay blocked:", e));
      });

      audio.play().catch(e => {
        const playAudio = () => {
          audio.play();
          document.removeEventListener("click", playAudio);
          document.removeEventListener("keydown", playAudio);
        };
        document.addEventListener("click", playAudio);
        document.addEventListener("keydown", playAudio);
      });

      const canvas = document.getElementById("gl");

      // Click anywhere to restart the sound
      canvas.addEventListener("click", () => {
        audio.currentTime = 0;
        audio.play();
      });

      const gl = canvas.getContext("webgl");
      if (!gl) { alert("WebGL not supported"); }

      function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = innerWidth * dpr;
        canvas.height = innerHeight * dpr;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      resize();
      addEventListener("resize", resize);

      function compile(src, type) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(s));
        }
        return s;
      }

      const vs = compile(
        `attribute vec2 p;
         void main(){
           gl_Position = vec4(p, 0.0, 1.0);
         }`,
        gl.VERTEX_SHADER
      );

      // ----- ‡¶®‡¶§‡ßÅ‡¶® ‡¶π‡ßÅ‡¶°‡¶ø / ‡¶π‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶∞ ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü‡ßç‡¶∞‡¶ø‡¶ï‡ßç‡¶∏ ‡¶ü‡¶æ‡¶á‡¶™ fragment shader -----
      const fs = compile(`
precision highp float;

uniform vec2  R;
uniform float T;
uniform float density;
uniform float scatter;
uniform float speed;
uniform float lightI;

float hash(vec2 p){
  p = fract(p * vec2(123.34, 456.21));
  p += dot(p, p + 45.32);
  return fract(p.x * p.y);
}

void main(){
  vec2 uv = gl_FragCoord.xy / R;
  vec2 cuv = (uv - 0.5) * 2.0;
  float dist = length(cuv);

  // ‡¶ï‡¶≤‡¶æ‡¶Æ/‡¶∞‡ßã ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ (density ‡¶¶‡¶ø‡ßü‡ßá ‡¶∏‡¶æ‡¶Æ‡¶æ‡¶®‡ßç‡¶Ø ‡¶®‡¶ø‡ßü‡¶®‡ßç‡¶§‡ßç‡¶∞‡¶£)
  float cols = 60.0 + density * 6.0;  // ~90 max
  float rows = 40.0 + density * 4.0;  // ~60 max

  // ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶¶‡¶ø‡¶ï‡ßá ‡¶ó‡¶§‡¶ø (speed ‡¶¶‡¶ø‡ßü‡ßá ‡¶¨‡¶æ‡ßú‡¶¨‡ßá)
  float t = T * (0.5 + speed * 0.3);

  float colId = floor(uv.x * cols);
  float rowId = floor((uv.y + t) * rows);

  float rnd = hash(vec2(colId, rowId));

  // ‡¶ï‡ßã‡¶® "‡¶°‡¶ø‡¶ú‡¶ø‡¶ü" ‡¶Ö‡¶® ‡¶•‡¶æ‡¶ï‡¶¨‡ßá
  float charOn = step(0.8, rnd);

  // rain head + trail
  float yPos   = fract(uv.y * rows + t + rnd * scatter);
  float trail  = exp(-yPos * 10.0);          // ‡¶®‡¶ø‡¶ö‡ßá ‡¶≤‡¶Æ‡ßç‡¶¨‡¶æ ‡¶∞‡ßá‡¶ñ‡¶æ
  float head   = smoothstep(0.0, 0.2, yPos); // ‡¶π‡ßá‡¶°‡ßá‡¶∞ ‡¶ó‡ßç‡¶≤‡ßã
  float inten  = (trail + head * 1.5) * charOn;

  vec3 baseGreen = vec3(0.1, 1.0, 0.4);
  float glow     = 0.5 + lightI * 0.1;       // lightI=5 -> 1.0
  vec3 col       = baseGreen * inten * glow;

  // ‡¶∏‡ßç‡¶ï‡ßç‡¶Ø‡¶æ‡¶®‡¶≤‡¶æ‡¶á‡¶® ‡¶á‡¶´‡ßá‡¶ï‡ßç‡¶ü
  float scan = sin(gl_FragCoord.y * 3.14159) * 0.04;
  col *= (1.0 - scan);

  // ‡¶≠‡¶ø‡¶ó‡¶®‡ßá‡¶ü (‡¶ö‡¶æ‡¶∞‡¶™‡¶æ‡¶∂ ‡¶°‡¶æ‡¶∞‡ßç‡¶ï)
  float vign = smoothstep(1.3, 0.3, dist);
  col *= vign;

  // ‡¶°‡¶æ‡¶∞‡ßç‡¶ï ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶ó‡ßç‡¶∞‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶¨‡ßÅ‡¶∏‡ßç‡¶ü
  col += vec3(0.0, 0.03, 0.0);

  gl_FragColor = vec4(col, 1.0);
}
`, gl.FRAGMENT_SHADER);

      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      gl.useProgram(prog);

      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([
          -1,-1,  1,-1, -1, 1,
          -1, 1,  1,-1,  1, 1
        ]),
        gl.STATIC_DRAW
      );

      const loc = {
        p:       gl.getAttribLocation(prog, "p"),
        R:       gl.getUniformLocation(prog, "R"),
        T:       gl.getUniformLocation(prog, "T"),
        density: gl.getUniformLocation(prog, "density"),
        scatter: gl.getUniformLocation(prog, "scatter"),
        speed:   gl.getUniformLocation(prog, "speed"),
        lightI:  gl.getUniformLocation(prog, "lightI")
      };

      gl.enableVertexAttribArray(loc.p);
      gl.vertexAttribPointer(loc.p, 2, gl.FLOAT, false, 0, 0);

      // ‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶Æ‡¶§‡¶á ‡¶Æ‡¶æ‡¶® ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶õ‡¶ø
      gl.uniform1f(loc.density, 5.0);
      gl.uniform1f(loc.scatter, 2.0);
      gl.uniform1f(loc.speed,   2.0);
      gl.uniform1f(loc.lightI,  5.0);

      let t0 = performance.now();
      function draw() {
        requestAnimationFrame(draw);
        gl.uniform2f(loc.R, canvas.width, canvas.height);
        gl.uniform1f(loc.T, (performance.now() - t0) / 1000.0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
      draw();
    </script>
  </body>
</html>
